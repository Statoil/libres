import json
import os
import os.path
import stat
import time
import datetime
from unittest import TestCase

from ecl.test import TestAreaContext
from res.job_queue import JobManager

# Test data generated by ForwardModel
JSON_STRING = """
{
  "DATA_ROOT" : "/path/to/data",
  "umask" : "0000",
  "jobList" : [ {"name" : "PERLIN",
  "executable" : "perlin.py",
  "target_file" : "my_target_file",
  "error_file" : "error_file",
  "start_file" : "some_start_file",
  "stdout" : "perlin.stdoit",
  "stderr" : "perlin.stderr",
  "stdin" : "intput4thewin",
  "argList" : ["-speed","hyper"],
  "environment" : {"TARGET" : "flatland"},
  "license_path" : "this/is/my/license/PERLIN",
  "max_running_minutes" : 12,
  "max_running" : 30
},
{"name" : "PERGEN",
  "executable" : "pergen.py",
  "target_file" : "my_target_file",
  "error_file" : "error_file",
  "start_file" : "some_start_file",
  "stdout" : "perlin.stdoit",
  "stderr" : "perlin.stderr",
  "stdin" : "intput4thewin",
  "argList" : ["-speed","hyper"],
  "environment" : {"TARGET" : "flatland"},
  "license_path" : "this/is/my/license/PERGEN",
  "max_running_minutes" : 12,
  "max_running" : 30
}],
 "ert_version" : [2, 2, "git"]
}
"""

JSON_STRING_NO_DATA_ROOT = """
{
  "umask" : "0000",
  "ert_version" : [2, 2, "git"],
  "jobList"   : []
}
"""

def gen_area_name(base, f):
    return base + "_" + f.func_name.split("_")[-1]

def create_jobs_py(jobList):
    jobs_file = os.path.join(os.getcwd(), "jobs.py")
    compiled_jobs_file = jobs_file + "c"

    for fname in [jobs_file, compiled_jobs_file]:
        if os.path.isfile(fname):
            os.unlink(fname)

    with open(jobs_file, "w") as f:
        f.write("jobList = ")
        f.write(json.dumps(jobList))
        f.write("\n")

    return jobs_file

def create_jobs_json(jobList, umask="0000"):
    data = {"umask"     : umask,
            "DATA_ROOT" : "/path/to/data",
            "jobList"   : jobList}

    jobs_file = os.path.join(os.getcwd(), "jobs.json")
    with open(jobs_file, "w") as f:
        f.write(json.dumps(data))

class JobManagerTest(TestCase):

    def setUp(self):
        self.dispatch_imp = None
        if "DATA_ROOT" in os.environ:
            del os.environ["DATA_ROOT"]

    def assert_clean_slate(self):
        self.assertFalse(os.path.isfile("jobs.py"))
        self.assertFalse(os.path.isfile("jobs.json"))

    def test_no_jobs_json(self):
        with TestAreaContext("no_jobs_json") as tac:
            self.assert_clean_slate()
            with self.assertRaises(IOError):
                jobm = JobManager(module_file="Does/not/exist",
                                  json_file="Neither/does/this/one")

    def test_repr(self):
        with TestAreaContext("jobman_repr"):
            self.assert_clean_slate()
            create_jobs_json([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            self.assertIn('len=1', repr(jobm))
            self.assertTrue(repr(jobm).startswith('JobManager('))

    def test_logged_fields(self):
        with TestAreaContext("jobman_repr"):
            self.assert_clean_slate()
            create_jobs_json([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            self.assertIn('kernel_version', jobm.information)
            self.assertIn('res_version', jobm.information)
            self.assertIn('ecl_version', jobm.information)

    def test_invalid_jobs_json(self):
        with TestAreaContext("invalid_jobs_json"):
            self.assert_clean_slate()
            # Syntax error
            with open("jobs.json", "w") as f:
                f.write("Hello - this is not valid JSON ...")

            with self.assertRaises(IOError):
                jobm = JobManager()

    def test_missing_joblist_json(self):
        with TestAreaContext("missing_joblist_json"):
            self.assert_clean_slate()
            with open("jobs.json", "w") as f:
                f.write(json.dumps({"umask" : "0000"}))

            with self.assertRaises(IOError):
                jobm = JobManager()

    def test_missing_umask_json(self):
        with TestAreaContext("test_missing_umask_json"):
            print os.getcwd()
            self.assert_clean_slate()
            with open("jobs.json", "w") as f:
                f.write(json.dumps({"jobList" : "[]"}))

            with self.assertRaises(IOError):
                jobm = JobManager()

    def test_indexing_json(self):
        with TestAreaContext("indexing_json"):
            self.assert_clean_slate()
            create_jobs_json([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            self.assertEqual(len(jobm), 1)

            job0 = jobm[0]
            with self.assertRaises(IndexError):
                _ = jobm[1]

            job0 = jobm["COPY_FILE"]
            with self.assertRaises(KeyError):
                _ = jobm["NO-SUCH-JOB"]

            self.assertTrue("COPY_FILE" in jobm)
            self.assertFalse("COPY_FILEX" in jobm)

    def test_jobs_py(self):
        with TestAreaContext("no_jobs_py"):
            with self.assertRaises(IOError):
                jobm = JobManager(module_file="Does/not/exist")

        with TestAreaContext("invalid_jobs"):
            # Syntax error
            with open("jobs.py", "w") as f:
                f.write("Hello - this is not valid Python code ...")
            with self.assertRaises(ImportError):
                jobm = JobManager()

            # Missing jobList attribute
            if os.path.isfile("jobs.pyc"):
                os.unlink("jobs.pyc")
            with open("jobs.py", "w") as f:
                f.write("A = 1")
            with self.assertRaises(AttributeError):
                jobm = JobManager()

            create_jobs_py([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            self.assertEqual(len(jobm), 1)

            job0 = jobm[0]
            with self.assertRaises(IndexError):
                _ = jobm[1]

            job0 = jobm["COPY_FILE"]
            with self.assertRaises(KeyError):
                _ = jobm["NO-SUCH-JOB"]

            self.assertTrue("COPY_FILE" in jobm)
            self.assertFalse("COPY_FILEX" in jobm)

    # This test breaks test_jobs_py if data is also
    # dumped as a python module
    def test_aaaa(self):
        with TestAreaContext("evil_by_name"):
            jobs_file = os.path.join(os.getcwd(), "jobs.json")

            with open(jobs_file, "w") as f:
                f.write(json.dumps({"A" : 1}))

            with self.assertRaises(IOError):
                jobm = JobManager()



    def test_post_error(self):
        self._test_post_error(create_jobs_py)
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_post_error(create_jobs)

    def _test_post_error(self, create_jobs):
        with TestAreaContext(gen_area_name("test_post_error", create_jobs)):
            create_jobs([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            job = {"name" : "TESTING",
                   "executable" : "/bin/testing/path",
                   "argList" : "arg1 arg2 arg3",
                   "stderr" : "stderr.txt",
                   "stdout" : "stdout.txt" }

            with open("stderr.txt","w") as f:
                f.write("stderr: %s\n" % datetime.datetime.now())

            with open("stdout.txt","w") as f:
                f.write("stdout: %s\n" % datetime.datetime.now())

            jobm.postError(job, "TESTING: Error message")

    def test_runtime(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_runtime(create_jobs)

    def _test_runtime(self, create_jobs):
        with TestAreaContext(gen_area_name("runtime", create_jobs)):
            create_jobs([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            start_time = jobm.getStartTime()
            time.sleep(5)
            run_time = jobm.getRuntime()
            self.assertTrue(run_time > 5)

    def test_statusfile(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_statusfile(create_jobs)

    def _test_statusfile(self, create_jobs):
        with TestAreaContext(gen_area_name("status_test", create_jobs)):
            with open(JobManager.STATUS_file, "w") as f:
                pass

            with open(JobManager.OK_file, "w") as f:
                pass

            with open(JobManager.EXIT_file, "w") as f:
                pass

            create_jobs([{'name' : 'COPY_FILE', 'executable' : 'XYZ'}])
            jobm = JobManager()
            for f in [JobManager.EXIT_file, JobManager.OK_file]:
                self.assertTrue(not os.path.exists(f))
            self.assertTrue(os.path.exists(jobm.STATUS_file))

            jobm.sleep_time = 0
            jobm.createOKFile()
            self.assertTrue(os.path.exists(jobm.OK_file))

    def test_run_job(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_run_job(create_jobs)

    def _test_run_job(self, create_jobs):
        with TestAreaContext(gen_area_name("run_job_fail", create_jobs)):
            with open("run.sh", "w") as f:
                f.write("#!/bin/sh\n")
                f.write("exit 1\n")
            st = os.stat("run.sh")
            os.chmod("run.sh", st.st_mode | stat.S_IEXEC)

            executable = os.path.join(os.getcwd(), "run.sh")
            joblist = [{"name" : "TEST_JOB",
                        "executable" : executable,
                        "argList" : ["A","B"]}]

            create_jobs(joblist)
            jobm = JobManager()
            self.assertTrue(os.path.isfile(executable))

            exit_status, msg = jobm.runJob(jobm[0])
            self.assertEqual(exit_status, 1)

    def test_verify_executable(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_verify_executable(create_jobs)

    def _test_verify_executable(self, create_jobs):
        with TestAreaContext(gen_area_name("no_executable", create_jobs)):
            with self.assertRaises(IOError):
                fname = "this/is/not/a/file"
                executable = os.path.join(os.getcwd(), fname)
                joblist = [{"name" : "TEST_EXECUTABLE_NOT_FOUND",
                            "executable" : executable,
                            "stdout" : "mkdir_out",
                            "stderr" : "mkdir_err",
                            "argList" : []}]

                create_jobs(joblist)
                jobm = JobManager()
                jobm.runJob(jobm[0])

        with TestAreaContext(gen_area_name("file_not_exec", create_jobs)):
            with self.assertRaises(IOError):
                fname = "not_executable"
                with open(fname, "w") as f:
                    f.write("#!/bin/sh\n")
                    f.write("exit 1\n")

                executable = os.path.join(os.getcwd(), fname)
                joblist = [{"name" : "TEST_JOB",
                            "executable" : executable,
                            "stdout" : "mkdir_out",
                            "stderr" : "mkdir_err",
                            "argList" : []}]

                create_jobs(joblist)
                jobm = JobManager()
                jobm.runJob(jobm[0])

        with TestAreaContext(gen_area_name("unix_cmd", create_jobs)):
            executable = "ls"
            self.assertFalse(os.path.isfile(executable))
            joblist = [{"name" : "TEST_UNIX_CMD_FROM_PATH",
                        "executable" : executable,
                        "stdout" : "mkdir_out",
                        "stderr" : "mkdir_err",
                        "argList" : []}]

            create_jobs(joblist)
            jobm = JobManager()
            jobm.runJob(jobm[0])

    def test_run_output_rename(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_run_output_rename(create_jobs)

    def _test_run_output_rename(self, create_jobs):
        with TestAreaContext(gen_area_name("output_rename", create_jobs)):
            job = {"name" : "TEST_JOB",
                   "executable" : "/bin/mkdir",
                   "stdout" : "out",
                   "stderr" : "err"}
            joblist = [ job,job, job, job, job ]
            create_jobs(joblist)
            jobm = JobManager()

            for (index,job) in enumerate(jobm):
                self.assertEqual(job["stderr"], "err.%d" % index)
                self.assertEqual(job["stdout"], "out.%d" % index)


    def test_run_multiple_OK(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_run_multiple_OK(create_jobs)

    def _test_run_multiple_OK(self, create_jobs):
        with TestAreaContext("mkdir"):
            joblist = []
            dir_list = ["1","2","3","4","5"]
            for d in dir_list:
                job = {"name" : "MKDIR",
                       "executable" : "/bin/mkdir",
                       "stdout" : "mkdir_out",
                       "stderr" : "mkdir_err",
                       "argList" : ["-p", "-v", d]}
                joblist.append(job)

            create_jobs(joblist)
            jobm = JobManager()

            for (index,job) in enumerate(jobm):
                exit_status, msg = jobm.runJob(job)
                self.assertEqual(exit_status, 0)

                self.assertTrue(os.path.isdir(dir_list[index]))
                self.assertTrue(os.path.isfile("mkdir_out.%d" % index))
                self.assertTrue(os.path.isfile("mkdir_err.%d" % index))
                self.assertEqual(0, os.path.getsize("mkdir_err.%d" % index))

    def test_run_multiple_fail(self):
        for create_jobs in [create_jobs_py, create_jobs_json]:
            self._test_run_multiple_fail(create_jobs)

    def _test_run_multiple_fail(self, create_jobs):
        with TestAreaContext(gen_area_name("mkdir", create_jobs)):
            joblist = []
            dir_list = ["1","2","3","4","5"]
            for d in dir_list:
                job = {"name" : "MKDIR",
                       "executable" : "/bin/mkdir",
                       "stdout" : "mkdir_out",
                       "stderr" : "mkdir_err",
                       "argList" : ["-p", "-v", "read-only/%s" % d]}
                joblist.append(job)

            create_jobs(joblist)
            jobm = JobManager()
            os.mkdir("read-only")
            os.chmod("read-only", stat.S_IRUSR + stat.S_IXUSR)

            for (index,job) in enumerate(jobm):
                exit_status, msg = jobm.runJob(job)
                self.assertEqual(exit_status, 1)
                self.assertTrue(os.path.getsize("mkdir_err.%d" % index) > 0)

    def test_json_over_py(self):
        with TestAreaContext("json_wins"):
            jobListPy = [{"name" : "PYTHON_JOB",
                   "executable" : "/bin/mkdir",
                   "stdout" : "out",
                   "stderr" : "err"}]

            jobListJson = [{"name" : "JSON_JOB",
                   "executable" : "/bin/mkdir",
                   "stdout" : "out",
                   "stderr" : "err"}]

            create_jobs_py(jobListPy)
            create_jobs_json(jobListJson)

            jobm = JobManager()
            self.assertEquals(jobListJson[0]["name"], jobm[0]["name"])

    def test_data_from_forward_model_json(self):
        with TestAreaContext("json_from_forward_model"):
            with open("jobs.json", "w") as f:
                f.write(JSON_STRING)

            jobm = JobManager()
            self.assertEquals("PERLIN", jobm[0]["name"])
            self.assertEqual( "/path/to/data" , jobm.data_root( ))
            self.assertEqual( "/path/to/data" , os.environ["DATA_ROOT"])

    def test_data_from_forward_model_json(self):
        with TestAreaContext("json_from_forward_model_NO_DATA_ROOT"):
            with open("jobs.json", "w") as f:
                f.write(JSON_STRING_NO_DATA_ROOT)

            jobm = JobManager()
            self.assertIsNone( jobm.data_root( ))
            self.assertNotIn( "DATA_ROOT" , os.environ )


    def test_blacklist(self):
        with TestAreaContext("file_server"):
            with open("jobs.json", "w") as f:
                f.write(JSON_STRING)

            jobm = JobManager()
            #  TODO FILE_SERVER_BLACKLIST is moved to job_dispatch
            # jobm.file_server = JobManager.FILE_SERVER_BLACKLIST[0]
            # jobm.checkFileServerBlackList()
            # self.assertTrue(os.path.isfile(""WARNING-ILLEGAL-FILESERVER.txt"))

            # TODO REMOVED test_load FROM jobmanager test!  Should be in ert-statoil
